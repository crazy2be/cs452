\documentclass[titlepage]{article}
\usepackage{listings}
\usepackage{hyperref}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}

\begin{document}
\title{Kernel 1}
\author{Justin McGirr (\#20413625), Peter Raboud (\#20437716)}
\maketitle

\section{Instructions}
\input{|"cat ../../README.md | sed -e '1,/BEGIN LaTeX INCLUDED/d' | pandoc -f markdown -t latex"}

\section{Design Decisions}
Very little has changed with the architecture of the kernel since the previous assignment.

One change was to actually store the current state of a task in it's task descriptor.
Previously, the state of the task could be inferred, and did not need to be explicitly stored.
(If a task was currently being executed, it is active; if in the ready queue, it is ready; otherwise
it is a zombie. No other possible states existed.)
We now need to store whether a task is in the \texttt{REPLY\_BLK} or \texttt{RECV\_BLK} states,
since this cannot be inferred by whether the task is on some particular queue.

We also added a send queue attached to each task descriptor.
This is a FIFO queue which maintains a list of task descriptors which wish to send a message
to that task.
The FIFO queue was actually already implemented as a subproblem of the priority queue used
for the ready queue, and so very little new code needed to be written for this.

\section{Source Code}
The source code is hosted on git, at \url{git.uwaterloo.ca/pgraboud/cs452-kernel}.
The version we wish to submit is on the \texttt{k1} branch, specifically
the commit:
\input{|"git rev-parse k1 | ./../verbatim"}
We are submitting the following files:
\input{|"cat ../file-list | ./../verbatim"}
\input{|"./../file-list | ./../verbatim"}

\section{Timings}
\input{|"python timings.py latex"}

\section{Questions}
We chose to give both the client and server tasks priorities lower than
the first user task, and give the server priority over the clients.
This is done to ensure that the server registers with the nameserver before
any of the clients attempt to look up the TID of the server.
By making the priority of the server higher, we then know that the server will
execute the call to \texttt{send()} wrapped by \texttt{register\_as()} before
any of the clients.
Since the nameserver processes requests in FIFO order, this is sufficient to
ensure that the server will register first.

We could have actually picked the priorities of the server and clients to be the
same, and then ensure that the server task is started first.
We could also have picked the relative priorities of the client and servers differently
without affecting the operation of the program.
However, giving them these priorities makes it somewhat easier to reason about
the order of execution.

The output produced by the rock-paper-scissors programs is as follows:

\begin{verbatim}
Boot...IO...
e1:0
e2:0
Client 4 connected
Client 3 connected
Client 6 connected
Client 5 connected
Client 3 drew round 0 with rock
Client 4 drew round 0 with rock
Client 5 won round 0 with paper
Client 6 lost round 0 with rock
Client 3 won round 1 by default, now quitting...
Client 4 quit
Client 6 drew round 1 with scissors
Client 5 drew round 1 with scissors
Client 5 lost round 2 with paper
Client 6 won round 2 with scissors
Client 5 won round 3 by default, now quitting...
RPS server done
Client 6 quit
\end{verbatim}

The first 3 lines are produced as part of the boot-up sequence of the kernel.

Each client uses its TID as its identifying number.

The next 4 connected lines are produced by the client after it connects for
the first time.
The lines are produced in pairs, as two clients are paired.
Since the clients begin executing in the order they were created, the lines are
overall ordered in ascending order of TID\@.
However, since the server replies to the second client of the pair first,
the order is reversed within each pair of lines.

Subsequent rounds are played by each client selecting a move by asking the kernel
for a pseudo-random number (generated by the Mersenne twister algorithm).
Each client decides on a random number of rounds to play at the start, which may not
be the same as the number its partner decides.
Subsequent lines each represent a pair of clients reporting the result of a round.
The order in which the clients report reverses each round, since the server replies to
the last client first.
Since the client which was last sends the message for the next round before it partner,
the roles reverse each round.

We then see that client 4 quits after only 1 round.
In round 2, it would have sent the quit response to the server after its partner, client 3,
sent its move to the server.
When the server responded to the quit request, replying to client 4, it first notified client 3
that it's partner quit.
We therefore see client 3 report that it won by default, and then exits.
Then, the server responds to client 4, which reports that it has quit, then exits.

The remaining lines follow much the same pattern as explained above.
\end{document}
